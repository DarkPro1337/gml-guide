[
{
	"uri": "https://darkpro1337.github.io/gml-guide/",
	"title": "Введение",
	"tags": [],
	"description": "",
	"content": " Введение Описание и прочая информация Добро пожаловать! Это руководство предназначено для новичков, у которых практически нет опыта работы с GameMaker Language или программирования в целом. Он познакомит вас с основами программирования и как работает GML. После этого руководства, вы сможете использовать GML для эффективного создания собственных игр!\nДобавьте эту страницу в закладки (Нажмите CTRL + D) так как это руководство довольно длинное, вы сможете закрыть его и вернутся к нему потом. Будет отлично, если вы прочитаете его залпом.\nДанное руководство было перенесено сюда мной, автором оригинального из руководств в Steam, ради удобства редактирования и чтения. Руководство в Steam останется там же, и удалять я его не буду.\n Само руководство полностью закончено, и никаких изменений кроме правок вносится не будет.\n Содержание  События Переменные Функции Условия – оператор if Условия и Функции Условия – оператор switch Функция repeat Цикл while Цикл do…while Цикл do…until Массивы Заключение  "
},
{
	"uri": "https://darkpro1337.github.io/gml-guide/events/",
	"title": "События",
	"tags": [],
	"description": "",
	"content": " Множество событий на выбор \nВы помещаете код внутри события, и этот код работает в зависимости от типа события, в который вы его поместили. В GameMaker есть много событий, которые вы можете выбрать.\nВот краткое введение в события, которые мы будем использовать больше всего:\nCreate (Создание) Код внутри события Create выполняется только один раз: когда экземпляр объекта, запускающий код, сначала создается. Здесь вы можете инициализировать большую часть основных переменных и/или придания движению объекту.\nStep (Шаг) Самое важное и наиболее часто используемое событие - событие Step запускается каждый шаг - если для вашей скорости игры/комнаты установлено значение 30, событие Step будет выполняться 30 раз в секунду. Это можно использовать для вещей, которые должны, повторятся постоянно.\nDraw (Рисование) Это событие используется для отрисовки. Например, такие функции, как draw_sprite, который используется для рисования спрайта, или draw_rectangle, который используется для рисования прямоугольника, работают только в событии Draw. Экземпляр объекта не будет отрисовываться (т.е. встроенный спрайт в сам объект), при условии если в событие Draw \u0026ldquo;что-то\u0026rdquo; есть, поэтому чтобы избежать этого - используют draw_self().\nAlarms (Таймер) События таймера запускаются после их установки. Поэтому, если я установил Alarm 0 до 60 в событии Create, код внутри события Alarm 0 будет запущен через 60 шагов.\nCollision (Столкновение) Добавляя событие столкновения, вы можете выбрать объект для создания события. Это событие будет выполняться только тогда, когда экземпляр, запускающий код, сталкивается с любым экземпляром объекта, указанным при создании события столкновения.\n"
},
{
	"uri": "https://darkpro1337.github.io/gml-guide/variables/",
	"title": "Переменные",
	"tags": [],
	"description": "",
	"content": " Объяснение Переменные - это контейнеры, содержащие некоторые значения/информацию. У них есть имя. Например, переменная с именем player_health может содержать 100, или переменная с именем player_name может содержать имя игрока («Питер», «Линдси» и т. д.). Зависит только от вас, что вы хотите назвать переменными и, что вы хотите хранить внутри них.\nПеременная в GML может хранить:\n Численные значения – 100, 45.534, -42.2 Строковые значения – \u0026quot;Учитель\u0026quot;, \u0026quot;Питер\u0026quot; Логические значения – true или false  Примеры Инициализация: price = 50;  Здесь мы инициализировали переменную с именем price, которая содержит 20 в качестве значения. Если переменная уже была инициализирована ранее, то эта будет изменять ее значение до 20.\nПримечание: в GML не обязательно помещать точку с запятой (;) после каждого утверждения. Поэтому не стесняйтесь пропустить её и сосредоточиться на главном коде.\n Присвоения значения price = 4 * 5; price = 40 / 2;  Увеличение значения price += 20;  Уменьшение значения price -= 20;  Умножение или деление значения price *= 2; price /= 2;  Использование Также вы можете использовать переменные в математических выражениях\u0026hellip;\na = 4; b = 5; c = a + b;  Здесь c будет хранить 9 из-за выражения a + b (что означает, что 4 + 5 как a равно 4, а b равно 5).\nРазличные типы переменных Локальные переменные Эти переменные инициализируются ключевым словом var. Они сбрасываются, когда событие было инициализировано в конце. Они могут использоваться только внутри события, если только не инициализированы снова.\nvar price = 2;  Этот код инициализирует локальную переменную price. Предположим, что событие, в котором находился этот код, было событием Step; то переменная может использоваться только в событии Step. Если вы попытаетесь использовать её без инициализации в другом событии, то она вернет ошибку, поскольку она там не существует.\nПеременные экземпляры Это обычные переменные, которые инициализируются путем присвоения значения.\nprice = 20;  Доступ к этим переменным возможен во всех событиях объекта/экземпляра, после того, как они был инициализированы.\nГлобальные переменные Это переменные, к которым могут получить доступ все объекты в вашей игре - отсюда и название «global». Существует два способа создания таких переменных:\nИнициализация с помощью ключевого слова globalvar globalvar price; price = 2;  Как только переменная была инициализирована через globalvar, она может использоваться любым экземпляром, присутствующим в комнате.\nИспользование с global.prefix global.price = 2;  Таким образом, вам не нужно инициализировать переменную с помощью globalvar, но вы должны использовать global.prefix каждый раз, когда вы хотите использовать эту переменную.\nВстроенные переменные Есть также некоторые встроенные переменные, которые означают что-то особенное в GameMaker. Вот несколько примеров:\nВстроенные переменные экземпляра Это встроенные переменные, которые уникальны для каждого экземпляра. Они также могут быть известны как свойства экземпляра. Вот несколько важных примеров:\nx: горизонтальное расположение экземпляра внутри комнаты (в пикселях) y: вертикальное расположение экземпляра внутри комнаты (в пикселях) speed: скорость экземпляра (в пикселях на шаг) direction: направление, в котором экземпляр перемещается (в градусах), по умолчанию: 0 hspeed: горизонтальная скорость (в пикселях/шаг) vspeed: вертикальная скорость (в пикселях / шаг) image_angle: вращение спрайта (в градусах), по умолчанию: 0 image_xscale: горизонтальное масштабирование спрайта, по умолчанию: 1 image_yscale: вертикальное масштабирование спрайта, по умолчанию: 1 image_index: суб-изображения спрайта, который отображает экземпляр image_speed: скорость, с которой спрайт меняет свои суб-изображения sprite_index: спрайт, используемый экземпляром  Вы можете изменять или использовать эти переменные так же, как обычные.\n//изменить местоположение на 200, 150 x = 200; y = 150; //сделать спрайт в 2 раза больше image_xscale = 2; image_yscale = 2; //вращение спрайта на 180 градусов (половину) image_angle = 180;  Текст, который появляется после //, является комментарием. Это не влияет на код; он там, чтобы вы могли объяснить, что делает ваш код, или писать важные вещи, которые вы хотели бы запомнить, глядя на ваш код. Вы также можете написать многострочные комментарии - просто запустите их с /* и закончите с помощью */.\n Встроенные глобальные переменные Эти встроенные переменные, которые являются глобальными для каждого экземпляра.\nВот несколько примеров:\nroom_speed: количество шагов, выполняемых комнатой за одну секунду, по умолчанию: 30 score: счет в вашей игре, может хранить любое числовое значение, хотя health: здоровье вашего игрока, тоже может хранить любое числовое значение lives: количество жизней, может также хранить любое числовое значение  Вот список всех встроенных переменных в GameMaker\n"
},
{
	"uri": "https://darkpro1337.github.io/gml-guide/functions/",
	"title": "Функции",
	"tags": [],
	"description": "",
	"content": " Объяснение Функции выполняют действие и/или возвращают значение, основанное на аргументах, приведенных в скобках, которые идут после имени функции. Если функция должна просто выполнять действие, она написана так:\nfunction(arg0, arg1, arg2...);  Но если он также возвращает что-то после выполнения действия, и вы хотите сохранить его в переменной, вы делаете это так:\nvariable = function(arg0, arg1, arg2...);  Функция может и не может содержать аргументы.\nПримеры instance_create_layer(x, y, layer, object); //Что он делает: создает экземпляр объекта в позиции x, y внутри слоя instance_create_layer(48, 48, \u0026quot;Instances\u0026quot;, obj_enemy); //Что он возвращает: ID экземпляра созданного экземпляра enemy_id = instance_create_layer(48, 48, \u0026quot;Instances\u0026quot;, obj_enemy); draw_sprite(sprite, sub-image, x, y); //Что он делает: Рисует суб-изображение спрайта в позиции x, y draw_sprite(spr_ball, 0, x+5, y+5); //Ничего не возвращает. random(number); //Ничего не делает. //Что он возвращает: возвращает случайное действительное число между 0 и числом. speed = random(5);  "
},
{
	"uri": "https://darkpro1337.github.io/gml-guide/if/",
	"title": "Условия – оператор if",
	"tags": [],
	"description": "",
	"content": " Объяснение Условия используются для управления выполнением некоторого кода. Используя условия, вы можете контролировать, работает ли фрагмент кода на основе условий. if оператор являются наиболее часто используемыми условиями. Используя if вы можете убедиться, что часть кода работает только при условии, что само условие или набор условий - истина (true).\nПример Допустим, вы делаете игру, и вы делаете магазин. Здесь игрок должен купить некоторые улучшения. Первое улучшение - улучшение оружия. Оно стоит 200 монет. Таким образом, игрок может купить его только в том случае, если это условие выполнено, то есть если у них есть как минимум 200 монет. В таком случае мы можем использовать условие if:\nif (coins\u0026gt;=200) { //купить улучшение }  Знак \u0026gt; открывается в сторону, которая больше, и = конечно же, означает равно. Итак, проверяя, if coins\u0026gt;=200, мы проверяем, больше ли 200 монет или они равны 200.\nТаким образом, игрок может купить улучшение только в том случае, если у него достаточно монет. Но что, если он этого не сделает? Мы должны уведомить его, что ему нужно больше монет. Но это нужно только тогда, когда условие не выполняется. Для этого мы используем else.\nif (coins\u0026gt;=200){ //купить улучшение } else{ //уведомить, что недостаточно монет }  Код после else выполняется только тогда, когда предыдущее условие if вернуло false. Поэтому, если у игрока меньше 200 монет, он будут уведомлен об этом.\nВы также можете поместить условие после else, так что даже после того, как прежнее условие вернет false, для выполнения кода потребуется еще одно условие else.\nТаким образом, вы можете добавить больше else и добавить разный код для разных условий:\nif (condition0){ //code0 } else if (condition1){ //code1 } else if (condition2){ //code2 } else{ //code3 }  Если condition0 истинно, code0 будет запущен, а остальная часть оператора if будет пропущена. Но если condition0 является ложным, оно перейдет к condition1. Если оно истинное, он выполнит code1 и остановится. Но если он тоже ложный, тогда он перейдет в condition2. Если это правда, code2 будет запущен, но если нет, оператор if, наконец, перейдет к последней части и увидит, что нет условия, и выполнится code3.\nПримечание В предыдущем примере мы проверили, были ли монеты больше либо равны 200. Но условия могут использоваться многими другими путями.\n//Проверка равного значения: if (money==400) //Для того чтобы это условие было истинным, money должна быть равна 400. //Проверка меньшего значения: if (money\u0026lt;50) /*Для того чтобы это условие было истинным, деньги должны быть меньше 50 (не более 49,99..)*/ //Проверка, что что-то не равно: if (name!=\u0026quot;CURSE\u0026quot;) /*Если имя игрока CURSE, это условие вернет false. Для того, чтобы это условие работало, name не должно быть равно значению.*/ //Другой пример: if (lives!=3) //Верно, только если lives не равно 3. //Проверка логического значения на истинность: if (paused==true) или if (paused) /*Истинно только тогда, когда переменная истинна, здесь это - paused. Вы можете пропустить часть \u0026quot;== true\u0026quot; и просто ввести имя переменной чтобы проверить, истина ли это.*/ //Проверка логического значения на ложность: if (paused==false) //или if (!paused) /*Истинно, если указанная переменная имеет значение false. Восклицательный знак (!) можно использовать в качестве префикса, что бы перевернуть его. Поэтому, если условие ложно, оно вернет true..*/  "
},
{
	"uri": "https://darkpro1337.github.io/gml-guide/conditions-and-functions/",
	"title": "Условия и Функции",
	"tags": [],
	"description": "",
	"content": " Объяснение Функции также могут использоваться внутри условий. Их можно либо проверять как логические значения (возврат true или false), либо через возврат определенного значения (числа/строки).\nВот несколько примеров, демонстрирующих, как функции могут использоваться внутри условий.\nplace_meeting() Функция place_meeting() может использоваться для проверки наличия столкновений между экземпляром, выполняющим код, и указанным объектом/экземпляром в позиции. Например,\n//код внутри obj_player: place_meeting(x, y, obj_wall);  Эта функция вернет true, если obj_wall сталкивается с obj_player в позиции последнего. Таким образом, чтобы проверить наличие коллизий и выполнить некоторый код, надо поставить эту функцию в условие:\n//obj_player событие \u0026quot;Step\u0026quot;: if (place_meeting(x, y, obj_wall)){ speed = 0; }  Когда происходит столкновение между obj_wall и obj_player, он устанавливает speed до 0.\ninstance_exists() Функция instance_exists() возвращает true, если экземпляр указанного объекта присутствует внутри комнаты.\n//Событие \u0026quot;Step\u0026quot;: if (instance_exists(obj_player)){ score += 1; }  Вышеприведенный код проверяет, существует ли экземпляр obj_player в комнате, и если это истина то, добавляет 1 к score.\nfloor() Функция floor() заполняет число, указанное в его круглых скобках, и возвращает результат. Например, 4.94 станет 4, так же 1.13 станет 1 и так далее.\nif (floor(image_index)==2){ image_index = 10; }  image_index хранит индекс суб-изображения, на котором в данный момент находится спрайт. Суб-изображения находятся в целых числах, но переменная image_index - нет. Поэтому, прежде чем проверять, какой суб-образ включен, вам нужно заполнить переменную.\n"
},
{
	"uri": "https://darkpro1337.github.io/gml-guide/switch/",
	"title": "Условия – оператор switch",
	"tags": [],
	"description": "",
	"content": "Возможно, как новичку, операторы switch, не будут очень полезны для вас, но все же вы должны знать о них.\nВ операторе switch вы сначала указываете переменную, функцию или комбинацию внутри математическом выражении. Затем вы перечисляете все возможные случаи. Оператор switch вычисляет указанное выражение и переходит к случаю, соответствующему результату. Он выполняет код, следующий за случаем, пока не будет найден разрыв.\nВот пример:\nswitch(level){ case 1: level_name = \u0026quot;Overworld\u0026quot;; break; case 2: level_name = \u0026quot;Underground\u0026quot;; break; case 3: level_name = \u0026quot;Water World\u0026quot;; break; case 4: level_name = \u0026quot;Castle\u0026quot;; break; default: level_name = \u0026quot;Unknown\u0026quot;; }  В этом примере level - это переменная, которая содержит номер уровня, на котором игрок находится в данный момент. Когда level равен 1, он переключится в case 1. Он будет запускать код, где он устанавливает level_name для «Overworld». Затем он сталкивается с break и останавливает код.\nЕсли вы не используете break перед запуском другого случая, он будет продолжать выполнять все случаи до тех пор, пока не будет найден разрыв.\n Аналогично, когда level равен 2, будет выполняться случай 2. То же самое для случаев 3 и 4.\nНо что, если level не соответствует ни одному из этих случаев? В такой ситуации switch перейдет к части default и запустит код идущий после него.\n"
},
{
	"uri": "https://darkpro1337.github.io/gml-guide/repeat/",
	"title": "Функция repeat",
	"tags": [],
	"description": "",
	"content": "Функция repeat() может повторять набор операторов определенное количество раз и используется так же, как и оператор if. Вот пример:\nrepeat(5){ coins += 1; }  Вы знаете, что coins += 1: добавляет 1 к переменной coins. Но поскольку мы используем repeat(5) перед ним, оператор будет выполняться 5 раз, в конечном итоге будет добавляться 5 к переменной coins (1 * 5 = 5).\nФункция repeat() представляет собой своего рода цикл, потому что он продолжает цикл, пока он не достигнет конца. Продолжай читать, чтобы узнать больше о циклах.\n"
},
{
	"uri": "https://darkpro1337.github.io/gml-guide/while/",
	"title": "Цикл while",
	"tags": [],
	"description": "",
	"content": "Итак, для начала - существуют разные типы циклов, а цикл while - один из них. Поскольку он самый простой, я сначала объясню его.\nЦиклы называются так, потому что они цикличны. Циклы как оператор if, в них есть условие которое должно быть выполнено для исполнения кода. Здесь рассмотрим оператор if в сравнении с циклом while:\nif (money \u0026gt; 40){ //код } while (money \u0026gt; 40){ //код }  Оператор if проверяет, больше ли money, чем 40, а затем выполняет код. Цикл while проверяет так же, но разница в том, как работает цикл.\nКогда условие, указанное для цикла, становится истинным, выполняется идущий после него код, и когда этот блок кода заканчивается, он возвращается к условию и проверяет его снова. Если условие истина, то он снова выполняет код. Затем снова и снова, и если это истина, снова выполняет код. Он продолжает это делать, проверяет условие, а затем код, и так пока условие не станет ложным.\nДавайте возьмем пример выше. Скажем, значение money становится больше 40. Цикл while выполнит код, и продолжит делать это до тех пор, пока условие не станет ложным. Для того, чтобы условие оказалось ложным, стоимость денег должна быть ниже или равна 40.\nwhile (money \u0026gt; 40){ //код money -= 1; }  Теперь все в порядке. Если мы уменьшаем значение money на каждый цикл, в какой-то момент оно должно опускаться ниже 40 и останавливать цикл.\nОбязательно чтобы вы реализовали, что условие в итоге стало ложным, и тем самым остановить цикл. Если вы этого не сделаете, то цикл станет бесконечным, который никогда не остановится и приведет к вылету вашей игры.\n"
},
{
	"uri": "https://darkpro1337.github.io/gml-guide/do-while/",
	"title": "Цикл do…while",
	"tags": [],
	"description": "",
	"content": "Это еще один цикл и вариант цикла while. Посмотрите как он выглядит, прежде чем я объясню как он работает:\ndo { //код } while (условие);  Не пугайтесь. Это очень просто.\nПомните, как в цикле while мы использовали проверку условия перед выполнением кода?\nwhile (условие){ //код }  В цикле do\u0026hellip;while часть while(условие) переместилась в нижнюю часть, после блока кода, и был заменен на do:\ndo{ //код } while (условие);  Это так потому, что цикл do..while сначала выполняет весь код, который находится в блоке кода, а затем проверяет условие, чтобы убедиться, что это истина, и должен ли он снова выполнить цикл. Если это так, он возвращается наверх и выполняет блок кода. Затем снова переходит к условию. Таким образом, он продолжает цикл до тех пор, пока условие не станет ложным, разница состоит в том, что он сначала выполняет блок кода, даже не проверяя условие.\nТочка с запятой (;) должна быть в конце цикла do\u0026hellip;while, потому что без нее конечная часть while(условие) может запутаться с запуском другого цикла while.\n"
},
{
	"uri": "https://darkpro1337.github.io/gml-guide/do-until/",
	"title": "Цикл do…until",
	"tags": [],
	"description": "",
	"content": "Цикл do\u0026hellip;until совпадает с циклом do\u0026hellip;while, причем разница заключается в том, что проверка условия do\u0026hellip;until перевернута. Поэтому в do\u0026hellip;while цикл будет работать снова, если условие было истинным, но в do\u0026hellip;until цикл будет выполняться только в том случае, если условие было ложным.\ncoins = 5; do{ coins++; }until (coins==10);  Это так же просто, как сказать: \u0026ldquo;Продолжайте добавлять 1 к coins, пока они не станут равны 10\u0026rdquo;. Будет продолжать добавлять 1 к монетам, и когда данное условие станет истинным, когда монеты будут равны 10, тогда цикл будет остановлен.\nВ GameMaker следует использовать do\u0026hellip;until, но не do\u0026hellip;while.\n"
},
{
	"uri": "https://darkpro1337.github.io/gml-guide/arrays/",
	"title": "Массивы",
	"tags": [],
	"description": "",
	"content": "Помните, как работают переменные? Вы можете дать им имя и сохранить в них некоторое значение:\ncoins = 10;  Это количество монет только одного игрока. Но что, если игроков 4, вам нужно хранить значение для каждого, и у них есть какое-то количество монет? Как бы вы это сделали?\ncoins0 = 10; coins1 = 5; coins2 = 12; coins3 = 7;  Сделать вот так, верно? Хранить все эти значения в разных переменных? Это будет работать верно, но есть и другой, более лучший способ сделать это: использовать массивы.\ncoins[0] = 10; coins[1] = 5; coins[2] = 12; coins[3] = 7;  Массивы похожи на переменные, у них также есть имя и хранятся некоторые значения, но в отличие от переменных они могут хранить несколько переменных (элементов) под тем же именем.\nЧтобы назначить или получить доступ к элементу внутри массива, поместите идентификатор элемента (число) в квадратные скобки после имени массива. Вот так:\narray[id] = value; variable = array[id];  Поэтому в предыдущем примере я добавил четыре элемента (0, 1, 2, 3) к массивам. Если я хочу сохранить второй элемент (со значением 5) к переменной с именем player_2, я сделаю следующее:\nplayer_2 = coins[1];  Вы также можете использовать переменную вместо идентификатора элемента внутри квадратных скобок, потому что главное - это значение, а не ключевое слово. Поэтому я могу сделать так:\ni = 1; player_2 = coins[i];  Также вы можете использовать массивы внутри цикла:\nfor(i=0; i\u0026lt;3; i++) { money[i] = coins[i]; }  Вышеупомянутый код выполняет ту же функцию, что и этот:\nmoney[0] = coins[0]; money[1] = coins[1]; money[2] = coins[2];  Поскольку цикл будет выполняться только 3 раза, когда переменная цикла i будет равна 0, 1 и 2 соответственно, первые три элемента массива money станут равными первым трем элементам массива coins.\n"
},
{
	"uri": "https://darkpro1337.github.io/gml-guide/conclusion/",
	"title": "Заключение",
	"tags": [],
	"description": "",
	"content": "Это всё для основ.\n  Автор оригинального руководства  Оригинал руководства на Английском  Видео-курс по GMS на Udemy (англ.)  Discord сервер, где вам могут помочь с GMS. (англ.)  Steam версия этого руководства  Удачного вам геймдева! :)\nЕсли вы находите ошибки в переводе, отправляйте поправки мне в DM: Twitter Telegram.\nТак же вы можете оставлять поправки к комментариям руководства в Steam.\n "
},
{
	"uri": "https://darkpro1337.github.io/gml-guide/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://darkpro1337.github.io/gml-guide/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]