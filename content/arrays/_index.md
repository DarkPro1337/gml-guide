---
title: "Массивы"
date: 2019-08-02T22:15:12+03:00
draft: false
weight: 65
pre: <b>11. </b>
---
Помните, как работают переменные? Вы можете дать им имя и сохранить в них некоторое значение:

```gml
coins = 10;
```

Это количество монет только одного игрока. Но что, если игроков 4, вам нужно хранить значение для каждого, и у них есть какое-то количество монет? Как бы вы это сделали?

```gml
coins0 = 10;
coins1 = 5;
coins2 = 12;
coins3 = 7;
```

Сделать вот так, верно? Хранить все эти значения в разных переменных? Это будет работать верно, но есть и другой, более лучший способ сделать это: использовать массивы.

```gml
coins[0] = 10;
coins[1] = 5;
coins[2] = 12;
coins[3] = 7;
```

Массивы похожи на переменные, у них также есть имя и хранятся некоторые значения, но в отличие от переменных они могут хранить несколько переменных \(элементов\) под тем же именем.

Чтобы назначить или получить доступ к элементу внутри массива, поместите идентификатор элемента \(число\) в квадратные скобки после имени массива. Вот так:

```gml
array[id] = value;
variable = array[id];
```

Поэтому в предыдущем примере я добавил четыре элемента \(0, 1, 2, 3\) к массивам. Если я хочу сохранить второй элемент \(со значением 5\) к переменной с именем `player_2`, я сделаю следующее:

```gml
player_2 = coins[1];
```

Вы также можете использовать переменную вместо идентификатора элемента внутри квадратных скобок, потому что главное - это значение, а не ключевое слово. Поэтому я могу сделать так:

```gml
i = 1;
player_2 = coins[i];
```

Также вы можете использовать массивы внутри цикла:

```gml
for(i=0; i<3; i++) {
    money[i] = coins[i];
}
```

Вышеупомянутый код выполняет ту же функцию, что и этот:

```gml
money[0] = coins[0];
money[1] = coins[1];
money[2] = coins[2];
```

Поскольку цикл будет выполняться только 3 раза, когда переменная цикла `i` будет равна 0, 1 и 2 соответственно, первые три элемента массива `money` станут равными первым трем элементам массива `coins`.
